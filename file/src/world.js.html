<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/world.js | picoes</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Pico Entity System for JavaScript (ES6)."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="picoes"><meta property="twitter:description" content="Pico Entity System for JavaScript (ES6)."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ayebear/picoes"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/memoized_query_index.js~MemoizedQueryIndex.html">MemoizedQueryIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/simple_index.js~SimpleIndex.html">SimpleIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/world.js~World.html">World</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/world.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** @ignore */
const { invoke, isFunction } = require(&apos;./utilities.js&apos;)

/** @ignore */
const { Entity } = require(&apos;./entity.js&apos;)

/** @ignore */
const { SimpleIndex } = require(&apos;./simple_index.js&apos;)

/**
 * Class for world.
 *
 * @class      World (name)
 */
class World {
	/**
	 * Constructs an instance of the world.
	 *
	 * @param      {Function}  [indexer=SimpleIndex]  The indexer to use. Default is SimpleIndex. Can use MemoizedQueryIndex if better querying performance is needed, for increased component creation/removal costs.
	 */
	constructor(indexer = SimpleIndex) {
		/** @ignore */
		this.systems = []

		/**
		 * Maps entity IDs to entities
		 * @ignore
		 */
		this.entities = new Map()

		/** @ignore */
		this.components = {}

		/** @ignore */
		this.entityTemplates = {}

		/** @ignore */
		this.idCounter = 1

		/**
		 * Maps entire queries to arrays of entities
		 * @ignore
		 */
		this.index = new indexer(this)

		/**
		 * Context information
		 */
		this.contextData = undefined
		this.contextKey = undefined
	}

	/**
	 * Removes all entities from the world.
	 * Does not affect registered systems, components, or prototypes.
	 *
	 * @example
	 * world.clear()
	 */
	clear() {
		// Call onRemove on all components of all entities
		for (const [entityId, entity] of this.entities) {
			for (let componentName in entity.data) {
				// Get component, and call onRemove if it exists as a function
				let component = entity.data[componentName]
				invoke(component, &apos;onRemove&apos;)
			}
		}

		// Clear entities
		this.entities = new Map()
		this.index.clear()
	}

	/**
	 * Registers a component type to the world. Components must be constructable. If the component has
	 * an onCreate(), it is passed all of the arguments from methods like entity.set(). Also, components
	 * can have an onRemove() method, which gets called when removing that component from an entity.
	 *
	 * @param {string}   name           - The name
	 * @param {function} componentClass - The component class, must be a constructable class or function
	 *
	 * @example
	 * world.component(&apos;myComponent&apos;, class {
	 *     // It is highly recommended to use onCreate() over constructor(), because the component
	 *     // will have already been added to the entity. In the constructor(), it is not safe to use
	 *     // &quot;entity&quot; because it does not contain the current component while still in the constructor.
	 *     onCreate(some, args) {
	 *         this.some = some
	 *         this.args = args
	 *         this.entity.set(&apos;whatever&apos;) // this.entity is auto-injected, and this is safe to do here
	 *     }
	 * })
	 * // entity === the new entity object
	 * // some === 10
	 * // args === 500
	 * world.entity().set(&apos;myComponent&apos;, 10, 500)
	 *
	 * @return {string} Registered component name on success, undefined on failure
	 */
	component(name, componentClass) {
		// Only allow functions and classes to be components
		if (isFunction(componentClass)) {
			this.components[name] = componentClass
			return name
		}
	}

	/**
	 * Creates a new entity in the world
	 *
	 * @param {string} [name] - The prototype name to use
	 *
	 * @example
	 * world.entity()
	 *
	 * @example
	 * world.entity(&apos;Player&apos;)
	 *
	 * @return {Entity} The new entity created
	 */
	entity(name) {
		let entityId = this.idCounter++
		let entity = new Entity(this, entityId)

		// Use &apos;name&apos; to get prototype data (if specified)
		if (name &amp;&amp; name in this.entityTemplates) {
			// Add all components from prototype
			let template = this.entityTemplates[name]
			for (let componentName in template) {
				// Update component with data from template
				let newComponentData = JSON.parse(template[componentName])
				entity.update(componentName, newComponentData)
			}
		}

		this.entities.set(entityId, entity)
		return entity
	}

	/**
	 * Sets a context object that is automatically injected into all existing and new systems.
	 * Calling this multiple times will overwrite any previous contexts passed. One caveat is that
	 * you can only start to use the injected context in systems starting with init(). It is not
	 * available in the constructor.
	 *
	 * @param {Object} [data] - The object to use as context to pass to systems
	 * @param {string} [key] - The top-level key to inject into systems for the context object.
	 * If no key is specified, then all the keys inside the context object will be spread into the
	 * top-level of the system.
	 *
	 * @example
	 * const state = { app: new PIXI.Application() }
	 * const world = new World()
	 * world.context(state) // systems can directly use this.app
	 * world.system(...)
	 *
	 * @example
	 * world.context(state, &apos;state&apos;) // systems use this.state.app
	 *
	 * @return {Entity} The new entity created
	 */
	context(data, key) {
		this.contextData = data
		this.contextKey = key

		// Update existing systems&apos; context
		for (const system of this.systems) {
			this._injectContext(system)
		}
	}

	/**
	 * Registers a system to the world.
	 * The order the systems get registered, is the order then run in.
	 *
	 * @example
	 * // Movement system (basic example)
	 * class MovementSystem {
	 *   run(dt) {
	 *     world.each(&apos;position&apos;, &apos;velocity&apos;, ({ position, velocity }) =&gt; {
	 *       position.x += velocity.x * dt
	 *       position.y += velocity.y * dt
	 *     })
	 *   }
	 * }
	 * // Input system (advanced example)
	 * class InputSystem {
	 *   init(key) {
	 *     // Have access to this.keyboard here, but not in constructor
	 *     this.key = key
	 *   }
	 *   run(dt) {
	 *     if (this.keyboard.isPressed(this.key)) {
	 *       world.each(&apos;controlled&apos;, &apos;velocity&apos;, ({ velocity }, entity) =&gt; {
	 *         // Start moving all controlled entities to the right
	 *         velocity.x = 1
	 *         velocity.y = 0
	 *         // Can also use the full entity here, in this case to add a new component
	 *         entity.set(&apos;useFuel&apos;)
	 *       })
	 *     }
	 *   }
	 * }
	 * // Inject context (see world.context())
	 * world.context({ keyboard: new Keyboard() })
	 * // Register systems in order (this method)
	 * world.system(InputSystem, &apos;w&apos;) // pass arguments to init/constructor
	 * world.system(MovementSystem)
	 * // Run systems (can get dt or frame time)
	 * world.run(1000.0 / 60.0)
	 *
	 * @param {Function} systemClass - The system class to instantiate. Can contain a
	 * constructor(), init(), run(), or any other custom methods/properties.
	 *
	 * @param {...Object} args - The arguments to forward to the system&apos;s constructor and init.
	 * Note that it is recommended to use init if using context, see world.context().
	 *
	 * @return {number} Unique ID of the system on success or undefined on failure
	 */
	system(systemClass, ...args) {
		// Make sure the system is valid
		if (isFunction(systemClass)) {
			// Create the system
			const newSystem = new systemClass(...args)

			// Inject context
			this._injectContext(newSystem)

			// Call init
			invoke(newSystem, &apos;init&apos;, ...args)

			// Add the system, return its ID
			return this.systems.push(newSystem) - 1
		}
	}

	/**
	 * Calls run() on all systems. These methods can return true to cause an additional rerun of all systems.
	 * Reruns will not receive the args passed into run(), as a way to identify reruns.
	 *
	 * @example
	 * world.run(deltaTime)
	 *
	 * @example
	 * // Example flow of method call order:
	 * // Setup systems:
	 * world.system(systemA)
	 * world.system(systemB)
	 * // During world.run():
	 * // systemA.run()
	 * // systemB.run()
	 *
	 * @param {...Object} [args] - The arguments to forward to the systems&apos; methods
	 */
	run(...args) {
		let status = true
		// Continue rerunning while any systems return true
		while (status) {
			status = undefined
			for (const system of this.systems) {
				// Try to call the &quot;run&quot; method
				const result = invoke(system, &apos;run&apos;, ...args)
				status = status || result
			}

			// Clear args after first run, so re-runs can be identified
			args = []
		}
	}

	/**
	 * Iterate through components and entities with all of the specified component names
	 *
	 * @example
	 * // Use a callback to process entities one-by-one
	 * world.each(&apos;comp&apos;, ({ comp }) =&gt; { comp.value = 0 })
	 *
	 * @example
	 * // Get an iterator for the entities
	 * const it = world.each(&apos;comp&apos;)
	 * for (let entity of it) {...}
	 *
	 * @example
	 * // Pass multiple components, arrays, use extra entity parameter,
	 * // and destructure components outside the query
	 * world.each(&apos;compA&apos;, [&apos;more&apos;, &apos;comps&apos;], &apos;compB&apos;, ({ compA, compC }, entity) =&gt; {
	 *   if (compC) compC.foo(compC.bar)
	 *   compA.foo = &apos;bar&apos;
	 *   entity.remove(&apos;compB&apos;)
	 * })
	 *
	 * @param {...Object} args - Can pass component names, arrays of component names, and a callback,
	 * in any order.
	 *
	 * **{...string}**: The component names to match entities with. This checks if the entity
	 * has ALL of the specified components, but does not check for additional components.
	 *
	 * **{Function}**: The callback to call for each matched entity. Takes (entity.data, entity).
	 * Entity data is an object of {[componentName]: [component]}, that can be destructured with syntax
	 * shown in the examples.
	 *
	 * @return {MapIterator} If no callback specified, then returns a one-time-use iterator to the entities.
	 * Otherwise, returns the last loop iteration status, returned by the callback.
	 */
	each(...args) {
		// Gather component names and a callback (if any) from args
		const compNames = []
		let callback
		for (const arg of args) {
			if (typeof arg === &apos;string&apos;) {
				compNames.push(arg)
			} else if (typeof arg === &apos;function&apos;) {
				callback = arg
			} else if (Array.isArray(arg)) {
				// Add 1-level deep arrays of strings as separate component names
				for (const name of arg) {
					compNames.push(name)
				}
			} else {
				throw new Error(
					`Unknown argument ${arg} with type ${typeof arg} passed to world.each().`
				)
			}
		}

		// Get indexed map of entities
		const entities = this.index.query(...compNames)

		if (callback) {
			// Go through the map of entities
			let status
			for (const entity of entities) {
				// Pass component data and the main entity
				status = callback(entity.data, entity)

				// Stop the iteration when the callback returns false
				if (status === false) {
					break
				}
			}
			return status
		}
		return entities
	}

	/**
	 * Returns an array of entities with matching components
	 * Simplified version of each(), returns an array instead of an iterator.
	 *
	 * @example
	 * const entities = world.get(&apos;player&apos;, &apos;sprite&apos;)
	 *
	 * @param {Array} componentNames - The component names to match on. See each() for how this matches.
	 *
	 * @return {Array} Array of entities, instead of iterator like each().
	 */
	get(...componentNames) {
		return [...this.each(componentNames)]
	}

	/**
	 * Returns an entity by ID
	 * Returns undefined if it doesn&apos;t exist
	 *
	 * @example
	 * world.getEntityById(123)
	 *
	 * @param {number} entityId - The entity ID to lookup for the entity
	 *
	 * @return {Entity} Entity if found, otherwise undefined
	 */
	getEntityById(entityId) {
		return this.entities.get(entityId)
	}

	/**
	 * Registers entity prototype(s). Any existing prototype names that are the same will be overwritten
	 *
	 * @example
	 * world.prototype({
	 *     Movable: {
	 *         position: {},
	 *         velocity: {}
	 *     }
	 * })
	 *
	 * @param {Object} data - Object structure to register as a prototype. Should be a dictionary with the top level keys
	 * being the prototype names. Can also be a JSON formatted string.
	 *
	 * @return {number} Number of prototypes added.
	 */
	prototype(data) {
		let count = 0

		// Convert to an object when given a string
		if (typeof data === &apos;string&apos;) {
			data = JSON.parse(data)
		}

		// Data must be an object at this point
		if (typeof data === &apos;object&apos;) {
			// Iterate through prototype names
			for (let protoName in data) {
				let inputObject = data[protoName]
				let protoObject = {}
				// Iterate through component names
				for (let compName in inputObject) {
					// Store strings of each component
					protoObject[compName] = JSON.stringify(
						inputObject[compName]
					)
				}
				this.entityTemplates[protoName] = protoObject
				++count
			}
		}

		return count
	}

	/**
	 * Injects context into a system based on current context state
	 * @ignore
	 */
	_injectContext(system) {
		if (this.contextData &amp;&amp; this.contextKey) {
			// Inject into specified key
			system[this.contextKey] = this.contextData
		} else if (this.contextData) {
			// Inject as keys of context
			for (const key in this.contextData) {
				system[key] = this.contextData[key]
			}
		}
	}
}

exports.World = World
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
